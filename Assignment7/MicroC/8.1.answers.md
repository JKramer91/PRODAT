## Exercise 8.1 

### Ex_3.c 

```bash
 [LDARGS; CALL (1, "L1"); STOP; Label "L1"; INCSP 1; GETBP; CSTI 1; ADD;
   CSTI 0; STI; INCSP -1; GOTO "L3"; Label "L2"; GETBP; CSTI 1; ADD; LDI;
   PRINTI; INCSP -1; GETBP; CSTI 1; ADD; GETBP; CSTI 1; ADD; LDI; CSTI 1; ADD;
   STI; INCSP -1; INCSP 0; Label "L3"; GETBP; CSTI 1; ADD; LDI; GETBP; CSTI 0;
   ADD; LDI; LT; IFNZRO "L2"; INCSP -1; RET 0]
```        
```bash 
CALL (1, "L1"); // main is called by us 
STOP;
Label "L1"; //Automatically assigned label to first encountered function. Here main.
  INCSP 1; // Dec(TypI, "i") //Allocate space for the i variable inside main
  GETBP; CSTI 1; ADD; //AccVar "i", get address of i at offset 1
  CSTI 0; // CSTI 0, put 0 on stack
  STI; // Store 0 in address i (Assign) 
  INSCP -1; // Remove result of assignment 
  GOTO "L3"; // Go into while-loop
Label "L2";
  GETBP; CSTI 1; ADD; // AccVar "i" - get address of i at offset 1
  LDI; // Access i on top of stack
  PRINTI; // Prints the value i
  INSCP -1; // Remove the value on stack. After print we dont need it anymore.
  GETBP; CSTI 1; ADD; // AccVar "i" - get address of i at offset 1
  GETBP; CSTI 1; ADD; // AccVar "i" - get address of i at offset 1
  LDI; // Access i on top of stack
  CSTI 1; // CSTI 1, put 1 on stack
  ADD; // ADD(i,1) -> i = i + 1
  STI; // Store result on address i.  
  INSCP -1; // Clean up/remove result of assignment
  INSCP 0; // Increment stack pointer with 0 
Label "L3"; //This is the while-loop 
  GETBP; CSTI 1; ADD; // AccVar "i", get address of i at offset 1
  LDI;                // Access i on top of stack 
  GETBP; CSTI 0; ADD; // AccVar "n", get address of n at offset 0
  LDI; // Access n which is -1 from i on top of stack
  LT; // LT assumes two arguments on top of stack. We have i and n. We do the comparison between i and n. If i is less than n, put result on top of stack (0 or 1)
  IFNZRO "L2"; // Assumes value on top of stack. If comparison != 0, go to body of while-loop (L2)
  INSCP -1; // Remove result of calculation from IFNZERO 
  RET 0; //We return 0 because it is a void function
```

### Ex_5.c

```java 

  [LDARGS; CALL (1, "L1"); STOP; Label "L1"; INCSP 1; GETBP; CSTI 1; ADD;
   GETBP; CSTI 0; ADD; LDI; STI; INCSP -1; INCSP 1; GETBP; CSTI 0; ADD; LDI;
   GETBP; CSTI 2; ADD; CALL (2, "L2"); INCSP -1; GETBP; CSTI 2; ADD; LDI;
   PRINTI; INCSP -1; INCSP -1; GETBP; CSTI 1; ADD; LDI; PRINTI; INCSP -1;
   INCSP -1; RET 0; Label "L2"; GETBP; CSTI 1; ADD; LDI; GETBP; CSTI 0; ADD;
   LDI; GETBP; CSTI 0; ADD; LDI; MUL; STI; INCSP -1; INCSP 0; RET 1]

```

```bash
Label "L1": //Main function 
  INSCP 1; // Dec(TypI, "r") - Allocate space for the variable r
  GETBP; CSTI 1; ADD; // AccVar "r", get address of r at offset 1  
  GETBP; CSTI 0; ADD; // AccVar "n" - get address of n at offset 0 
  LDI; // Access n on top of stack
  STI; // Store n in r -> r = n
  INSCP -1; //  Remove result from assignment
  INSCP 1; // Dec(TypI, "r") - Allocate space for the inner r variable of the block
  GETBP; CSTI 0; ADD; // AccVar "n" -> Get address of n at offset 0
  LDI; // Load n which is on top of stack 
  GETBP; CSTI 2; ADD; // AccVar "r" - > Get address of n at offset 2 
  CALL (2, "L2"); // Call with 2 args and call L2 which is the label 
  INSCP -1; // Remove dummy value from RET from L 2
  GETBP; CSTI 2; ADD; // AccVar "r" -> get address of r at offset 2 
  LDI; // Load r, the value on top of stack 
  PRINTI; // Print r 
  INCSP -1; // Remove inner r at offset 2 (the inner scope r)
  INCSP -1; // 
  GETBP; CSTI 1; ADD; // AccVar "r" -> Get address of r at offset 1
  LDI; // Return value on top of stack (r at offset 1) 
  PRINTI; // Print r
  INCSP -1; // Remove outer r from stack 
  INCSP -1; // 
  RET 0; //Return 0 cause void function 
Label "L2";
  GETBP; CSTI 1;ADD; // AccVar "rp" at offset 1 
  LDI; // Access rp on top of stack
  GETBP; CSTI 0; ADD; // AccVar "i" at offset 0
  LDI; //Access i on top of stack
  GETBP; CSTI 0; ADD; //AccVar "i" at offset 0
  LDI; // Access i on top of stack
  MUL; // Multiply the two top elements of stack, which is i and i. i*i
  STI; // Store result of multiplication in *rp
  INSCP -1; // Remove result of assignment. result is stored in rp, so we remove top element
  INSCP 0; // hehe
  RET 1; // Return to calling function 
```

```c

void main(int n) {
  int r; 
  r = n;
  { 
    int r;
    square(n, &r);
    print r;
  }
  print r;
}

void square(int i, int *rp) {
  *rp = i * i;
}

```

### Note that ex5.c has a nested scope (a block ... inside a function body); how is that visible in the generated code? 
We can see it in the following:
```bash
STI; // Store n in r -> r = n
 INSCP -1; //  Remove result from assignment
  INSCP 1; // Dec(TypI, "r") - Allocate space for the inner r variable of the block
  GETBP; CSTI 0; ADD; // AccVar "n" -> Get address of n at offset 0
  LDI; // Load n which is on top of stack 
  GETBP; CSTI 2; ADD; // AccVar "r" - > Get address of r at offset 2 
  ```
  - We remove the result of the assignment of r=n after the store.
  - Then when the block starts we allocate space for the new inner variable, which is also called r.
  - Because it is a new scope, it gets a new offset ( a new address). We access this inner r in the block inside of the function body by getting Base Pointer at offset 2, where as the old r is at offset 1. 

